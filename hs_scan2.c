// PICTURE OF TA GUIN

/*⠀
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠋⠉⠈⠉⠉⠉⠉⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣿⣿
⣿⣿⣿⣿⡏⣀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿
⣿⣿⣿⢏⣴⣿⣷⠀⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿
⣿⣿⣟⣾⣿⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣷⢢⠀⠀⠀⠀⠀⠀⠀⢸⣿
⣿⣿⣿⣿⣟⠀⡴⠄⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⣿
⣿⣿⣿⠟⠻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠶⢴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣿
⣿⣁⡀⠀⠀⢰⢠⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⡄⠀⣴⣶⣿⡄⣿
⣿⡋⠀⠀⠀⠎⢸⣿⡆⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⠗⢘⣿⣟⠛⠿⣼
⣿⣿⠋⢀⡌⢰⣿⡿⢿⡀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⡇⠀⢸⣿⣿⣧⢀⣼
⣿⣿⣷⢻⠄⠘⠛⠋⠛⠃⠀⠀⠀⠀⠀⢿⣧⠈⠉⠙⠛⠋⠀⠀⠀⣿⣿⣿⣿⣿
⣿⣿⣧⠀⠈⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠀⠀⠀⠀⢀⢃⠀⠀⢸⣿⣿⣿⣿
⣿⣿⡿⠀⠴⢗⣠⣤⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡸⠀⣿⣿⣿⣿
⣿⣿⣿⡀⢠⣾⣿⠏⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠉⠀⣿⣿⣿⣿
⣿⣿⣿⣧⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿
⣿⣿⣿⣿⡄⠈⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣦⣄⣀⣀⣀⣀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠙⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠁⠀⠀⠹⣿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⠿⠛⠉⠉⠁⠀⢻⣿⡇⠀⠀⠀⠀⠀⠀⢀⠈⣿⣿⡿⠉⠛⠛⠛⠉⠉
⣿⡿⠋⠁⠀⠀⢀⣀⣠⡴⣸⣿⣇⡄⠀⠀⠀⠀⢀⡿⠄⠙⠛⠀⣀⣠⣤⣤⠄⠀
*/

// INCLUDES:

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <math.h>
#include <string.h>
#include <assert.h>

// GLOBALS:

pthread_mutex_t mutex;
int* input_g;  // global input
int* mid_g;  // global sums in the middle of each step
int* sums_g;  // global prefix sums array
int size_g;  // global size
int nt_g;  // global number of threads
int t_ready_g = 0;  // cond var for barrier 1
int t_ready2_g = 0;  // cond var for barrier 2

// FUNCTIONS:

int calculateLoops(int tn, int jump)
{  // calculate how many loops thread (tn) needs to take this step
	int R = 0;  // return value
	int jumps_left = (size_g - jump);

	while(jumps_left > nt_g)
	{
		{  // figure out how many loops this thread needs to take
			R++;
			jumps_left -= nt_g;
		}
	}
	if(jumps_left >= tn)
	{
		R++;
	}

	return R;
}

void printSums()
{
	for(int i = 0; i < size_g; i++)
	{
		printf("%d\n", sums_g[i]);
	}
}

void* threadFunction(void* arg)
{
	int tn = *((long*) arg);  // this thread's number
	int step = 1;  // step/row counter
	int jump = 1;  // jump size for this step, first jump is 2^0 = 1
	int loops;  // how many loops this thread needs to take this loop
	int index;  // variable to decrease overall calculations

	while(jump < size_g)
	{
		loops = calculateLoops(tn, jump);
		for(int i = 0; i < loops; i++)
		{  // counts loops
			index = ((size_g - 1) - (tn - 1) - (nt_g * i));
			mid_g[index] = (input_g[index] + input_g[index - jump]);
		}
		pthread_mutex_lock(&mutex);  // lock so two threads cannot change value at same time (yes this happened in our testing)
		t_ready_g++;  // thread is ready to memcpy()
		pthread_mutex_unlock(&mutex);
		while(t_ready_g < (step * nt_g));  // barrier
		memcpy(input_g, mid_g, (size_g * sizeof(int)));
		pthread_mutex_lock(&mutex);  // lock so two threads cannot change value at same time (yes this happened in our testing)
		t_ready2_g++;  // thread is ready to move on to next step
		pthread_mutex_unlock(&mutex);
		while(t_ready2_g < (step * nt_g));
		step++;
		jump = (1 << (step - 1));
	}
	for(int i = 0; i < size_g; i++)
	{  // set values in prefix sum array
		if(sums_g[i] != input_g[i])
		{
			//printf("thread%d sets sums[%d] to %d\n", tn, i, input_g[i]);
			sums_g[i] = input_g[i];
		}
	}

	return 0;
}

void production(int* input, int size, int nt)
{
	pthread_t* threads = (pthread_t*) malloc(size_g * sizeof(pthread_t));
	int tn[nt_g];  // array to store thread numbers (ids)

	for(int i = 0; i < nt; i++)
	{  // create (nt) threads
		tn[i] = (i + 1);  // assign id to each thread
		pthread_create(&threads[i], NULL, threadFunction, (void*) &tn[i]);
	}
	for(int i = 0; i < nt; i++)
	{  // wait for all threads to finish executing
		pthread_join(threads[i], NULL);
	}
	printSums();
	free(threads);
}

int main()
{
	int input[20] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 1, 1, 1, 1};  // input array
	int size = 20;  // size of input array
	int nt = 2;  // number of threads
	int sums[size];
	int mid[size];

	input_g = input;
	size_g = size;
	nt_g = nt;
	sums_g = sums;
	mid_g = mid;
	memcpy(mid_g, input_g, (size_g * sizeof(int)));  // set mid_g to input
	memcpy(sums_g, input_g, (size_g * sizeof(int)));  // set sums_g to input

	production(input, size, nt);

	return 0;
}
